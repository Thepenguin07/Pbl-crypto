import hashlib
import os
from PIL import Image
import tkinter as tk
from tkinter import filedialog, messagebox
class ImageCipher:
    def __init__(self, secret_key, num_rounds=16):
        self.num_rounds = num_rounds
        self.block_size = 16
        self.half_block = self.block_size // 2
        self.round_keys = self._make_round_keys(secret_key)
    def _make_round_keys(self, secret_key):
        key_hash = hashlib.sha256(secret_key.encode()).digest()
        keys_list = []
        for i in range(self.num_rounds):
            key_data = key_hash + i.to_bytes(4, 'big')
            new_key = hashlib.sha256(key_data).digest()[:self.half_block]
            keys_list.append(new_key)
        return keys_list
    def _feistel_function(self, data_block, round_key):
        data_num = int.from_bytes(data_block, 'big')
        key_num = int.from_bytes(round_key, 'big')
        mixed = data_num ^ key_num
        bit_count = self.half_block * 8
        rotated = ((mixed << 3) & (2**bit_count - 1)) | (mixed >> (bit_count - 3))
        return rotated.to_bytes(self.half_block, 'big')
    def _process_block(self, data_block, keys):
        left_part = data_block[:self.half_block]
        right_part = data_block[self.half_block:]
        for key in keys:
            temp = left_part
            left_part = right_part
            right_mixed = self._feistel_function(right_part, key)
            right_part = bytes(a ^ b for a, b in zip(temp, right_mixed))
        return right_part + left_part
    def _add_padding(self, data):
        padding_size = self.block_size - (len(data) % self.block_size)
        if padding_size == 0:
            padding_size = self.block_size
        return data + bytes([padding_size] * padding_size)

    def _strip_padding(self, data):
        if not data:
            raise ValueError("Empty data, cannot strip padding")

        padding_size = data[-1]
        if padding_size < 1 or padding_size > self.block_size:
            raise ValueError("Invalid padding size. Wrong key or corrupt data.")

        expected_padding = bytes([padding_size] * padding_size)
        if data[-padding_size:] != expected_padding:
            raise ValueError("Invalid padding. Wrong key or corrupt data.")

        return data[:-padding_size]

    def encrypt_data(self, input_data):
        padded_data = self._add_padding(input_data)

        iv = os.urandom(self.block_size)
        encrypted_blocks = []
        previous_block = iv

        for i in range(0, len(padded_data), self.block_size):
            block = padded_data[i:i+self.block_size]
            block_to_encrypt = bytes(a ^ b for a, b in zip(block, previous_block))
            encrypted_block = self._process_block(block_to_encrypt, self.round_keys)
            encrypted_blocks.append(encrypted_block)
            previous_block = encrypted_block

        return iv + b''.join(encrypted_blocks)

    def decrypt_data(self, input_data):
        if len(input_data) < self.block_size * 2:
            raise ValueError("Invalid data length. Too short.")

        iv = input_data[:self.block_size]
        ciphertext = input_data[self.block_size:]

        if len(ciphertext) % self.block_size != 0:
            raise ValueError("Invalid ciphertext length.")

        decrypted_blocks = []
        decryption_keys = self.round_keys[::-1]
        previous_block = iv

        for i in range(0, len(ciphertext), self.block_size):
            block = ciphertext[i:i+self.block_size]
            decrypted_block_xor = self._process_block(block, decryption_keys)
            plain_block = bytes(a ^ b for a, b in zip(decrypted_block_xor, previous_block))
            decrypted_blocks.append(plain_block)
            previous_block = block

        return self._strip_padding(b''.join(decrypted_blocks))
def get_image_bytes(img_path):
    with Image.open(img_path) as img:
        if img.mode != 'RGB':
            img = img.convert('RGB')
        return img.tobytes(), img.size, img.mode

def create_image_package(pixel_data, dimensions, color_mode):
    width, height = dimensions
    mode_bytes = color_mode.encode('utf-8')
    header = width.to_bytes(4, 'big') + height.to_bytes(4, 'big') + len(mode_bytes).to_bytes(1, 'big') + mode_bytes
    return header + pixel_data

def parse_image_package(package_data):
    width = int.from_bytes(package_data[0:4], 'big')
    height = int.from_bytes(package_data[4:8], 'big')
    mode_len = package_data[8]
    mode = package_data[9:9+mode_len].decode('utf-8')
    pixels = package_data[9+mode_len:]
    return pixels, (width, height), mode

def save_image_from_bytes(pixel_data, dimensions, mode, path):
    img = Image.frombytes(mode, dimensions, pixel_data)
    img.save(path)

def encrypt_image_file(source, target, password, rounds):
    pixels, size, mode = get_image_bytes(source)
    pkg = create_image_package(pixels, size, mode)
    cipher = ImageCipher(password, rounds)
    enc = cipher.encrypt_data(pkg)
    with open(target, 'wb') as f:
        f.write(enc)

def decrypt_image_file(source, target, password, rounds):
    with open(source, 'rb') as f:
        enc = f.read()
    cipher = ImageCipher(password, rounds)
    dec = cipher.decrypt_data(enc)
    pixels, size, mode = parse_image_package(dec)
    save_image_from_bytes(pixels, size, mode, target)
class CipherGUI:
    def __init__(self, root):
        self.root = root
        root.title("Image Cipher")
        root.geometry("420x320")
        root.resizable(False, False)
        self.mode = tk.StringVar(value="encrypt")
        tk.Label(root, text="Image Encryption / Decryption", font=("Segoe UI", 14, "bold")).pack(pady=10)
        tk.Button(root, text="Select File", command=self.select_file, width=20).pack(pady=5)
        self.file_label = tk.Label(root, text="No file selected", fg="#555")
        self.file_label.pack()
        tk.Label(root, text="Password:").pack(pady=(15, 0))
        self.password_entry = tk.Entry(root, show='*', width=30)
        self.password_entry.pack()
        mode_frame = tk.Frame(root)
        mode_frame.pack(pady=10)
        tk.Radiobutton(mode_frame, text="Encrypt", variable=self.mode, value="encrypt").pack(side=tk.LEFT, padx=10)
        tk.Radiobutton(mode_frame, text="Decrypt", variable=self.mode, value="decrypt").pack(side=tk.LEFT, padx=10)
        tk.Label(root, text="Rounds (default 16):").pack()
        self.rounds_entry = tk.Entry(root, width=10)
        self.rounds_entry.insert(0, "16")
        self.rounds_entry.pack()
        tk.Button(root, text="Run", command=self.run_cipher, width=20, bg="#1e90ff", fg="white").pack(pady=15)
        self.selected_file = None
    def select_file(self):
        path = filedialog.askopenfilename(filetypes=[("All files", ".")])
        if path:
            self.selected_file = path
            self.file_label.config(text=os.path.basename(path))
    def run_cipher(self):
        if not self.selected_file:
            messagebox.showerror("Error", "Select a file first.")
            return
        password = self.password_entry.get().strip()
        if not password:
            messagebox.showerror("Error", "Password required.")
            return
        try:
            rounds = int(self.rounds_entry.get().strip())
        except:
            messagebox.showerror("Error", "Rounds must be numeric.")
            return
        if self.mode.get() == "encrypt":
            out = filedialog.asksaveasfilename(defaultextension=".dat", initialfile="encrypted.dat")
            if not out:
                return
            try:
                encrypt_image_file(self.selected_file, out, password, rounds)
                messagebox.showinfo("Success", "Encrypted successfully.")
            except Exception as e:
                messagebox.showerror("Error", str(e))
        else:
            out = filedialog.asksaveasfilename(defaultextension=".png", initialfile="decrypted.png")
            if not out:
                return
            try:
                decrypt_image_file(self.selected_file, out, password, rounds)
                messagebox.showinfo("Success", "Decrypted successfully.")
            except Exception as e:
                messagebox.showerror("Error", str(e))
if __name__ == "__main__":
    root = tk.Tk()
    CipherGUI(root)
    root.mainloop()
